# üöÄ PLAN MAESTRO PARA TOP TIER - MENUPILOT
## Gemini 3 Hackathon - Estrategia de Victoria

**Objetivo:** Alcanzar Top 3 del Hackathon Gemini 3  
**Score Target:** 4.7+ / 5.0 (Percentil 98+)  
**Tiempo Disponible:** 9 d√≠as (hasta Feb 9, 2026 @ 5:00 PM PST)  
**Tiempo de Trabajo Estimado:** 60-70 horas (~7-8 d√≠as efectivos)  

---

## üìã √çNDICE DEL PLAN

1. [Resumen Ejecutivo](#resumen-ejecutivo)
2. [Timeline Maestro](#timeline-maestro)
3. [Fase 1: Features Cr√≠ticas (Creative Autopilot)](#fase-1-creative-autopilot)
4. [Fase 2: Vibe Engineering Completo](#fase-2-vibe-engineering)
5. [Fase 3: Marathon Agent Robusto](#fase-3-marathon-agent)
6. [Fase 4: Optimizaciones T√©cnicas](#fase-4-optimizaciones)
7. [Fase 5: Frontend Integration](#fase-5-frontend)
8. [Fase 6: Demo Video & Presentaci√≥n](#fase-6-presentacion)
9. [Fase 7: Testing & QA](#fase-7-testing)
10. [Fase 8: Submission Final](#fase-8-submission)
11. [Plan de Contingencia](#plan-contingencia)

---

## üéØ RESUMEN EJECUTIVO

### Estado Actual vs. Objetivo

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    TRANSFORMATION PLAN                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  ACTUAL:                                                    ‚îÇ
‚îÇ  Score:           3.52 / 5.0  (70%)                        ‚îÇ
‚îÇ  Percentil:       60-70  (Top 35%)                         ‚îÇ
‚îÇ  Prob Top 3:      5-8%                                     ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚ñº‚ñº‚ñº IMPLEMENTAR MEJORAS ‚ñº‚ñº‚ñº                              ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  OBJETIVO:                                                  ‚îÇ
‚îÇ  Score:           4.7+ / 5.0  (94%+)                       ‚îÇ
‚îÇ  Percentil:       97-99  (Top 1-3%)                        ‚îÇ
‚îÇ  Prob Top 3:      40-60%                                   ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  DELTA:           +1.18 puntos (+24%)                      ‚îÇ
‚îÇ  Mejora Percentil: +35 puntos                              ‚îÇ
‚îÇ  Prob Premio:      +35-52%                                 ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Features a Implementar (Prioridad)

**üî¥ CR√çTICAS (NO NEGOCIABLES):**
1. Creative Autopilot + Nano Banana Pro
2. Vibe Engineering Completo
3. Grounding Sistem√°tico Verificado
4. Demo Video Espectacular

**üü° IMPORTANTES (ALTO IMPACTO):**
5. Marathon Agent Robusto
6. Frontend Integration Premium
7. Streaming Responses
8. Screenshots Profesionales

**üü¢ NICE-TO-HAVE (PULIDO):**
9. Instagram Performance Predictor
10. Menu Transformation Studio
11. Testing Coverage > 80%
12. Performance Optimization

---

## üìÖ TIMELINE MAESTRO (9 D√çAS)

### Distribuci√≥n de Tiempo

```
D√çA 1-2:  Features Cr√≠ticas (Creative Autopilot, Vibe)     [16h]
D√çA 3:    Marathon Agent + Grounding                       [8h]
D√çA 4:    Frontend Integration                             [8h]
D√çA 5-6:  Demo Video + Presentaci√≥n                        [12h]
D√çA 7:    Testing E2E + Bug Fixes                          [8h]
D√çA 8:    Pulido + Screenshots + Docs                      [6h]
D√çA 9:    Buffer + Submission Final                        [4h]
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
TOTAL:                                                       62h
```

### Timeline Detallado

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ D√çA 1 - S√ÅBADO 1 FEB (8 horas)                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-12:00 ‚îÇ Creative Autopilot Backend (Parte 1)         [4h]  ‚îÇ
‚îÇ 13:00-15:00 ‚îÇ Creative Autopilot Backend (Parte 2)         [2h]  ‚îÇ
‚îÇ 15:00-17:00 ‚îÇ Testing Creative Autopilot B√°sico            [2h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 2 - DOMINGO 2 FEB (8 horas)                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-10:00 ‚îÇ Vibe Engineering Backend                     [2h]  ‚îÇ
‚îÇ 10:00-12:00 ‚îÇ Vibe Engineering Integration                 [2h]  ‚îÇ
‚îÇ 13:00-15:00 ‚îÇ Grounding Sistem√°tico                        [2h]  ‚îÇ
‚îÇ 15:00-17:00 ‚îÇ Testing + Bug Fixes D√≠a 1-2                  [2h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 3 - LUNES 3 FEB (8 horas)                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-11:00 ‚îÇ Marathon Agent con Checkpoints               [3h]  ‚îÇ
‚îÇ 11:00-13:00 ‚îÇ WebSocket Real-Time Updates                  [2h]  ‚îÇ
‚îÇ 14:00-17:00 ‚îÇ Streaming Responses                          [3h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 4 - MARTES 4 FEB (8 horas)                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-10:00 ‚îÇ Frontend: Creative Autopilot UI              [2h]  ‚îÇ
‚îÇ 10:00-12:00 ‚îÇ Frontend: Vibe Engineering UI                [2h]  ‚îÇ
‚îÇ 13:00-15:00 ‚îÇ Frontend: Marathon Progress UI               [2h]  ‚îÇ
‚îÇ 15:00-17:00 ‚îÇ Frontend: WebSocket Integration              [2h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 5 - MI√âRCOLES 5 FEB (6 horas)                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-10:00 ‚îÇ Script de Video Demo                         [2h]  ‚îÇ
‚îÇ 10:00-12:00 ‚îÇ Preparar Data de Demo                        [2h]  ‚îÇ
‚îÇ 14:00-16:00 ‚îÇ Grabaci√≥n de Pantalla (Raw Footage)          [2h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 6 - JUEVES 6 FEB (6 horas)                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-11:00 ‚îÇ Edici√≥n de Video                             [3h]  ‚îÇ
‚îÇ 11:00-13:00 ‚îÇ Voiceover + M√∫sica                           [2h]  ‚îÇ
‚îÇ 14:00-15:00 ‚îÇ Export Final + Revisi√≥n                      [1h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 7 - VIERNES 7 FEB (8 horas)                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-11:00 ‚îÇ Testing E2E Completo                         [3h]  ‚îÇ
‚îÇ 11:00-14:00 ‚îÇ Bug Fixes Cr√≠ticos                           [3h]  ‚îÇ
‚îÇ 15:00-17:00 ‚îÇ Testing de Regresi√≥n                         [2h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 8 - S√ÅBADO 8 FEB (6 horas)                                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-10:00 ‚îÇ Screenshots Profesionales                    [2h]  ‚îÇ
‚îÇ 10:00-12:00 ‚îÇ Actualizar README + Docs                     [2h]  ‚îÇ
‚îÇ 13:00-15:00 ‚îÇ Diagrams + Architecture Visuals              [2h]  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ D√çA 9 - DOMINGO 9 FEB (4 horas)                                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 08:00-10:00 ‚îÇ Revisi√≥n Final + Checklist                   [2h]  ‚îÇ
‚îÇ 10:00-12:00 ‚îÇ Preparar Submission                          [2h]  ‚îÇ
‚îÇ 12:00-17:00 ‚îÇ BUFFER (emergencias)                         [5h]  ‚îÇ
‚îÇ 17:00       ‚îÇ üöÄ SUBMISSION DEADLINE                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üé® FASE 1: CREATIVE AUTOPILOT + NANO BANANA PRO

### Objetivo
Implementar el feature visual m√°s impactante del hackathon: generaci√≥n de campa√±as de marketing completas con assets visuales profesionales.

### Tiempo Total: 6 horas (D√≠a 1)

---

### 1.1 Backend: Creative Autopilot Agent (4 horas)

**Archivo:** `backend/app/services/gemini/creative_autopilot.py`

```python
"""
Creative Autopilot Agent - Generaci√≥n de Campa√±as Visuales con Nano Banana Pro

Este m√≥dulo implementa el track estrat√©gico "Creative Autopilot" del Gemini 3 Hackathon.

Capacidades:
- Generaci√≥n de assets visuales 4K con texto legible
- Localizaci√≥n visual (traducir texto dentro de imagen)
- A/B testing con variaciones autom√°ticas
- Multi-reference branding (hasta 14 im√°genes de referencia)
- Grounding con Google Search para tendencias

Diferenciador clave: Nano Banana Pro es EXCLUSIVO de Gemini 3.
"""

from google import genai
from google.genai import types
from typing import List, Dict, Optional
import base64
import json
import asyncio
from datetime import datetime
from ..base_agent import GeminiBaseAgent, ThinkingLevel, ThoughtSignature

class CreativeAutopilotAgent(GeminiBaseAgent):
    """
    Agente especializado en generaci√≥n de campa√±as visuales.
    
    Usa Nano Banana Pro (gemini-3-pro-image-preview) para generar:
    - Posts de Instagram con texto legible en espa√±ol
    - Stories verticales
    - Banners web
    - Flyers imprimibles en alta resoluci√≥n
    """
    
    def __init__(self):
        # Usar modelo espec√≠fico de imagen
        super().__init__(
            model="gemini-3-pro-image-preview",  # Nano Banana Pro
            temperature=0.8  # Mayor creatividad para generaci√≥n visual
        )
        self.reasoning_model = "gemini-3-flash-preview"  # Para estrategia
    
    async def generate_full_campaign(
        self,
        restaurant_name: str,
        dish_data: Dict,
        bcg_classification: str,
        brand_guidelines: Optional[Dict] = None,
        target_languages: List[str] = ["es", "en"],
        thinking_level: ThinkingLevel = ThinkingLevel.DEEP
    ) -> Dict:
        """
        Genera una campa√±a visual COMPLETA para un plato.
        
        Args:
            restaurant_name: Nombre del restaurante
            dish_data: {
                "name": str,
                "description": str,
                "price": float,
                "category": str,
                "image_url": str (opcional)
            }
            bcg_classification: "star" | "cash_cow" | "question_mark" | "dog"
            brand_guidelines: {
                "colors": ["#FF5733", "#C70039"],
                "logo_path": "/path/to/logo.png",
                "fonts": ["Montserrat", "Playfair Display"],
                "brand_voice": "casual y cercano"
            }
            target_languages: Idiomas para localizaci√≥n
        
        Returns:
            {
                "strategy": {...},
                "creative_concept": {...},
                "visual_assets": [...],
                "ab_variants": [...],
                "localized_versions": {...},
                "estimated_impact": {...},
                "thought_signature": {...}
            }
        """
        
        print(f"üé® Iniciando Creative Autopilot para '{dish_data['name']}'...")
        
        # PASO 1: An√°lisis estrat√©gico (¬øqu√© mensaje comunicar?)
        strategy = await self._analyze_campaign_strategy(
            dish_data,
            bcg_classification,
            thinking_level
        )
        
        # PASO 2: Generaci√≥n de concepto creativo (¬øc√≥mo visualizarlo?)
        creative_concept = await self._generate_creative_concept(
            restaurant_name,
            dish_data,
            strategy,
            brand_guidelines,
            thinking_level
        )
        
        # PASO 3: Generar assets visuales con Nano Banana Pro
        visual_assets = await self._generate_visual_assets(
            creative_concept,
            brand_guidelines
        )
        
        # PASO 4: Generar variaciones A/B
        ab_variants = await self._generate_ab_variants(
            visual_assets[0],  # Partir del primer asset
            strategy
        )
        
        # PASO 5: Localizar a m√∫ltiples idiomas
        localized_versions = await self._localize_campaign(
            visual_assets,
            target_languages
        )
        
        # PASO 6: Estimar impacto
        estimated_impact = await self._estimate_campaign_impact(
            strategy,
            creative_concept,
            bcg_classification
        )
        
        # Generar thought signature
        thought_signature = self._generate_thought_signature(
            reasoning=f"""
            Campa√±a generada usando Creative Autopilot:
            
            1. Estrategia: {strategy['main_message']}
            2. Concepto creativo: {creative_concept['description'][:100]}...
            3. Assets generados: {len(visual_assets)} tipos
            4. Variantes A/B: {len(ab_variants)}
            5. Idiomas: {len(target_languages)}
            
            Diferenciador: Nano Banana Pro gener√≥ texto legible en espa√±ol
            dentro de las im√°genes, capacidad exclusiva de Gemini 3.
            """,
            level=thinking_level,
            confidence=0.92,
            sources=strategy.get('trending_sources', [])
        )
        
        return {
            "strategy": strategy,
            "creative_concept": creative_concept,
            "visual_assets": visual_assets,
            "ab_variants": ab_variants,
            "localized_versions": localized_versions,
            "estimated_impact": estimated_impact,
            "thought_signature": thought_signature.to_dict(),
            "metadata": {
                "model_used": self.model,
                "generation_timestamp": datetime.now().isoformat(),
                "total_assets_generated": len(visual_assets) + len(ab_variants)
            }
        }
    
    async def _analyze_campaign_strategy(
        self,
        dish_data: Dict,
        bcg_classification: str,
        thinking_level: ThinkingLevel
    ) -> Dict:
        """
        An√°lisis estrat√©gico: ¬øQu√© mensaje comunicar?
        
        Usa reasoning model para an√°lisis l√≥gico.
        """
        
        # Mapeo de clasificaci√≥n BCG a estrategia
        bcg_strategies = {
            "star": {
                "focus": "Destacar popularidad y calidad premium",
                "tone": "Aspiracional, exclusivo",
                "cta": "Prueba nuestro favorito de la casa"
            },
            "cash_cow": {
                "focus": "Enfatizar valor y consistencia",
                "tone": "Confiable, familiar",
                "cta": "El cl√°sico que siempre satisface"
            },
            "question_mark": {
                "focus": "Crear curiosidad e intriga",
                "tone": "Misterioso, innovador",
                "cta": "Descubre nuestra joya escondida"
            },
            "dog": {
                "focus": "Reinventar o promocionar fuertemente",
                "tone": "Urgente, especial",
                "cta": "Oferta especial por tiempo limitado"
            }
        }
        
        base_strategy = bcg_strategies.get(bcg_classification, bcg_strategies["star"])
        
        prompt = f"""
        Eres un ESTRATEGA DE MARKETING DIGITAL especializado en restaurantes.
        
        PLATO A PROMOCIONAR:
        {json.dumps(dish_data, indent=2)}
        
        CLASIFICACI√ìN BCG: {bcg_classification}
        
        ESTRATEGIA BASE:
        {json.dumps(base_strategy, indent=2)}
        
        INVESTIGACI√ìN (usa Google Search):
        1. Busca tendencias actuales de food marketing en redes sociales
        2. Identifica qu√© tipo de contenido genera m√°s engagement para {dish_data['category']}
        3. Revisa ejemplos de campa√±as exitosas similares
        
        TAREA:
        Desarrolla una estrategia de campa√±a espec√≠fica para este plato.
        
        Devuelve JSON:
        {{
            "main_message": "mensaje principal de 10-15 palabras",
            "key_selling_points": ["punto 1", "punto 2", "punto 3"],
            "target_audience": {{
                "primary": "descripci√≥n",
                "secondary": "descripci√≥n"
            }},
            "emotional_triggers": ["trigger 1", "trigger 2"],
            "competitive_angle": "qu√© nos diferencia",
            "optimal_platforms": ["Instagram", "Facebook", "TikTok"],
            "best_posting_times": ["horario y raz√≥n"],
            "trending_hashtags": ["#hashtag1", "#hashtag2"],
            "trending_sources": ["URL 1", "URL 2"],
            "confidence": 0.0-1.0
        }}
        """
        
        # Usar reasoning model con grounding
        client = genai.Client(api_key=self.settings.GEMINI_API_KEY)
        response = await client.aio.models.generate_content(
            model=self.reasoning_model,
            contents=prompt,
            config=types.GenerateContentConfig(
                tools=[{"google_search": {}}],  # Grounding activado
                response_mime_type="application/json",
                temperature=0.7
            )
        )
        
        strategy = json.loads(response.text)
        
        # Extraer fuentes de grounding
        if hasattr(response, 'grounding_metadata') and response.grounding_metadata:
            strategy['trending_sources'] = [
                chunk.uri for chunk in response.grounding_metadata.grounding_chunks
            ] if response.grounding_metadata.grounding_chunks else []
        
        return strategy
    
    async def _generate_creative_concept(
        self,
        restaurant_name: str,
        dish_data: Dict,
        strategy: Dict,
        brand_guidelines: Optional[Dict],
        thinking_level: ThinkingLevel
    ) -> Dict:
        """
        Genera el concepto creativo visual.
        """
        
        prompt = f"""
        Eres un DIRECTOR CREATIVO DE CLASE MUNDIAL especializado en food photography.
        
        BRIEF DE CAMPA√ëA:
        - Restaurante: {restaurant_name}
        - Plato: {dish_data['name']}
        - Mensaje: {strategy['main_message']}
        - Tono: {strategy.get('emotional_triggers', [])}
        
        BRAND GUIDELINES:
        {json.dumps(brand_guidelines or {}, indent=2)}
        
        TAREA:
        Dise√±a un concepto visual memorable para esta campa√±a.
        
        Devuelve JSON:
        {{
            "headline": "t√≠tulo pegajoso de 5-8 palabras",
            "tagline": "subt√≠tulo de 10-15 palabras",
            "visual_description": "descripci√≥n detallada de la composici√≥n visual",
            "color_palette": ["#HEX1", "#HEX2", "#HEX3"],
            "typography_style": "moderna y sans-serif | cl√°sica y serif | etc",
            "photo_style": "descripci√≥n del estilo fotogr√°fico",
            "key_visual_elements": ["elemento 1", "elemento 2"],
            "mood": "aspiracional | casual | lujoso | etc",
            "layout_notes": "notas sobre disposici√≥n de elementos"
        }}
        """
        
        result = await self.generate_content(
            prompt=prompt,
            thinking_level=thinking_level,
            response_format="application/json"
        )
        
        return result["content"]
    
    async def _generate_visual_assets(
        self,
        concept: Dict,
        brand_guidelines: Optional[Dict]
    ) -> List[Dict]:
        """
        Genera m√∫ltiples assets usando Nano Banana Pro.
        
        DIFERENCIADOR CLAVE:
        - Texto legible en espa√±ol dentro de la imagen
        - Multi-reference images (hasta 14 referencias)
        - Alta resoluci√≥n (4K)
        """
        
        assets = []
        
        # Asset 1: Post de Instagram (1080x1080)
        instagram_post = await self._generate_instagram_post(concept, brand_guidelines)
        assets.append(instagram_post)
        
        # Asset 2: Story de Instagram (1080x1920)
        instagram_story = await self._generate_instagram_story(concept, brand_guidelines)
        assets.append(instagram_story)
        
        # Asset 3: Banner web (1200x628)
        web_banner = await self._generate_web_banner(concept, brand_guidelines)
        assets.append(web_banner)
        
        # Asset 4: Flyer imprimible (2480x3508 - A4 en 300dpi)
        printable_flyer = await self._generate_printable_flyer(concept, brand_guidelines)
        assets.append(printable_flyer)
        
        return assets
    
    async def _generate_instagram_post(
        self,
        concept: Dict,
        brand_guidelines: Optional[Dict]
    ) -> Dict:
        """
        Genera post de Instagram con texto legible.
        
        CAPACIDAD EXCLUSIVA DE NANO BANANA PRO:
        - Texto en espa√±ol perfectamente legible
        - Tipograf√≠a profesional
        - Integraci√≥n natural en el dise√±o
        """
        
        # Preparar referencias de marca
        reference_images = []
        if brand_guidelines and 'logo_path' in brand_guidelines:
            try:
                with open(brand_guidelines['logo_path'], 'rb') as f:
                    logo_data = base64.b64encode(f.read()).decode('utf-8')
                    reference_images.append({
                        "inline_data": {
                            "mime_type": "image/png",
                            "data": logo_data
                        }
                    })
            except Exception as e:
                print(f"‚ö†Ô∏è No se pudo cargar logo: {e}")
        
        colors_str = ", ".join(brand_guidelines.get('colors', ['c√°lidos', 'apetitosos'])) if brand_guidelines else "c√°lidos y apetitosos"
        
        prompt = f"""
        Crea un post de Instagram PROFESIONAL con las siguientes especificaciones:
        
        CONCEPTO:
        {concept['visual_description']}
        
        TEXTO A INCLUIR EN LA IMAGEN:
        T√≠tulo principal: "{concept['headline']}"
        Subt√≠tulo: "{concept['tagline']}"
        
        REQUISITOS T√âCNICOS:
        - Formato: 1080x1080px (cuadrado perfecto)
        - Texto en ESPA√ëOL con tipograf√≠a {concept.get('typography_style', 'moderna')}
        - El texto debe ser PERFECTAMENTE LEGIBLE
        - Colores: {colors_str}
        - Estilo fotogr√°fico: {concept.get('photo_style', 'food photography profesional')}
        - Mood: {concept.get('mood', 'aspiracional')}
        
        COMPOSICI√ìN:
        - El plato debe ser el elemento principal
        - Usar regla de tercios
        - Espacio negativo para respirar
        - Profundidad de campo (desenfoque de fondo)
        
        IMPORTANTE:
        - El texto debe estar integrado naturalmente en el dise√±o
        - NO usar efectos excesivos
        - El resultado debe verse profesional, no generado por IA
        - Incluir elementos visuales sutiles que representen: {concept.get('key_visual_elements', [])}
        
        INVESTIGACI√ìN (usa Google Search):
        Busca las tendencias actuales de dise√±o en Instagram para food posts
        y aplica t√©cnicas contempor√°neas de composici√≥n.
        """
        
        # Construir contenido con referencias
        content_parts = [{"text": prompt}]
        content_parts.extend(reference_images[:14])  # M√°ximo 14 referencias
        
        # Generar con Nano Banana Pro + Grounding
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=content_parts,
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE', 'TEXT'],
                tools=[{"google_search": {}}],
                temperature=0.8,
                top_p=0.95
            )
        )
        
        # Extraer imagen generada
        generated_image = None
        reasoning = None
        
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
            elif hasattr(part, 'text') and part.text:
                reasoning = part.text
        
        # Extraer fuentes de grounding
        grounding_sources = []
        if hasattr(response, 'grounding_metadata') and response.grounding_metadata:
            if response.grounding_metadata.grounding_chunks:
                grounding_sources = [
                    chunk.uri for chunk in response.grounding_metadata.grounding_chunks
                ]
        
        return {
            "type": "instagram_post",
            "format": "1080x1080",
            "image_data": generated_image,
            "image_base64": generated_image,  # Ya est√° en base64
            "reasoning": reasoning,
            "concept_headline": concept['headline'],
            "concept_tagline": concept['tagline'],
            "grounding_sources": grounding_sources,
            "generation_timestamp": datetime.now().isoformat()
        }
    
    async def _generate_instagram_story(
        self,
        concept: Dict,
        brand_guidelines: Optional[Dict]
    ) -> Dict:
        """
        Genera Instagram Story (formato vertical).
        """
        
        colors_str = ", ".join(brand_guidelines.get('colors', ['vibrantes'])) if brand_guidelines else "vibrantes"
        
        prompt = f"""
        Crea un Instagram STORY (formato vertical) con estas especificaciones:
        
        CONCEPTO: {concept['visual_description']}
        
        TEXTO: "{concept['headline']}"
        
        FORMATO: 1080x1920px (vertical, 9:16)
        TEXTO: En espa√±ol, grande y legible para m√≥vil
        COLORES: {colors_str}
        ESTILO: Din√°mico, optimizado para visualizaci√≥n r√°pida en m√≥vil
        
        COMPOSICI√ìN VERTICAL:
        - Tercio superior: Espacio para texto principal
        - Tercio medio: Imagen del plato (hero)
        - Tercio inferior: CTA o informaci√≥n adicional
        
        El dise√±o debe ser THUMB-STOPPING (que detenga el scroll).
        """
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.85
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            "type": "instagram_story",
            "format": "1080x1920",
            "image_data": generated_image,
            "image_base64": generated_image,
            "concept_headline": concept['headline']
        }
    
    async def _generate_web_banner(
        self,
        concept: Dict,
        brand_guidelines: Optional[Dict]
    ) -> Dict:
        """
        Genera banner para sitio web (OG image compatible).
        """
        
        prompt = f"""
        Crea un BANNER WEB profesional:
        
        FORMATO: 1200x628px (Open Graph standard)
        CONCEPTO: {concept['visual_description']}
        TEXTO: "{concept['headline']}" + "{concept['tagline']}"
        
        COMPOSICI√ìN HORIZONTAL:
        - Lado izquierdo: Imagen del plato
        - Lado derecho: Texto y CTA
        
        Optimizado para compartir en redes sociales (preview de link).
        El texto debe ser legible incluso en thumbnail peque√±o.
        """
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.75
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            "type": "web_banner",
            "format": "1200x628",
            "image_data": generated_image,
            "image_base64": generated_image,
            "og_compatible": True
        }
    
    async def _generate_printable_flyer(
        self,
        concept: Dict,
        brand_guidelines: Optional[Dict]
    ) -> Dict:
        """
        Genera flyer imprimible en alta resoluci√≥n.
        """
        
        prompt = f"""
        Crea un FLYER IMPRIMIBLE de alta calidad:
        
        FORMATO: 2480x3508px (A4, 300dpi)
        CONCEPTO: {concept['visual_description']}
        TEXTO: Todo el copy necesario en espa√±ol
        
        DISE√ëO PRINT-READY:
        - Alta resoluci√≥n para impresi√≥n
        - M√°rgenes de seguridad (0.5cm)
        - CMYK-friendly colors
        - Tipograf√≠a clara y profesional
        
        Incluir:
        - Imagen hero del plato
        - T√≠tulo llamativo
        - Descripci√≥n breve
        - Precio (si aplica)
        - Informaci√≥n de contacto
        
        Dise√±o elegante y profesional, listo para imprimir.
        """
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.7
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            "type": "printable_flyer",
            "format": "2480x3508",
            "image_data": generated_image,
            "image_base64": generated_image,
            "print_ready": True,
            "dpi": 300
        }
    
    async def _generate_ab_variants(
        self,
        base_asset: Dict,
        strategy: Dict
    ) -> List[Dict]:
        """
        Genera variaciones A/B del asset base.
        
        Variaciones:
        - Cambio de √°ngulo de c√°mara
        - Cambio de iluminaci√≥n
        - Cambio de color grading
        """
        
        variants = []
        
        # Variante A: Vista cenital (top-down)
        variant_a = await self._transform_camera_angle(
            base_asset,
            "cenital (top-down), t√≠pico de food photography"
        )
        variant_a['variant_type'] = 'camera_angle_topdown'
        variants.append(variant_a)
        
        # Variante B: Iluminaci√≥n dorada (golden hour)
        variant_b = await self._transform_lighting(
            base_asset,
            "golden hour lighting, c√°lido y apetitoso"
        )
        variant_b['variant_type'] = 'lighting_golden'
        variants.append(variant_b)
        
        # Variante C: Minimalista monocrom√°tico
        variant_c = await self._transform_color_grading(
            base_asset,
            "minimalista con paleta restringida, elegante"
        )
        variant_c['variant_type'] = 'color_minimalist'
        variants.append(variant_c)
        
        return variants
    
    async def _transform_camera_angle(
        self,
        base_asset: Dict,
        new_angle: str
    ) -> Dict:
        """
        Transforma el √°ngulo de c√°mara manteniendo el concepto.
        """
        
        prompt = f"""
        Toma la composici√≥n de esta imagen y recr√©ala con un nuevo √°ngulo de c√°mara.
        
        NUEVO √ÅNGULO: {new_angle}
        
        IMPORTANTE:
        - Mant√©n EXACTAMENTE el mismo texto y ubicaci√≥n
        - Mant√©n los mismos colores y estilo
        - SOLO cambia la perspectiva de la c√°mara
        - El plato debe verse igual de apetitoso
        
        La transformaci√≥n debe ser sutil pero notable.
        """
        
        # Convertir imagen base si es necesario
        base_image = base_asset.get('image_base64') or base_asset.get('image_data')
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=[
                {"text": prompt},
                {
                    "inline_data": {
                        "mime_type": "image/jpeg",
                        "data": base_image
                    }
                }
            ],
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.6
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            **base_asset,
            "image_data": generated_image,
            "image_base64": generated_image,
            "transformation": f"camera_angle: {new_angle}",
            "is_variant": True
        }
    
    async def _transform_lighting(
        self,
        base_asset: Dict,
        new_lighting: str
    ) -> Dict:
        """
        Cambia la iluminaci√≥n manteniendo el resto.
        """
        
        prompt = f"""
        Aplica una nueva iluminaci√≥n a esta imagen.
        
        NUEVA ILUMINACI√ìN: {new_lighting}
        
        MANTENER:
        - Todo el texto exactamente igual
        - Composici√≥n id√©ntica
        - Colores base (ajustar solo temperatura)
        
        CAMBIAR:
        - Solo la iluminaci√≥n y sombras
        - Temperatura de color si es apropiado
        
        El resultado debe verse natural, no sobre-procesado.
        """
        
        base_image = base_asset.get('image_base64') or base_asset.get('image_data')
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=[
                {"text": prompt},
                {
                    "inline_data": {
                        "mime_type": "image/jpeg",
                        "data": base_image
                    }
                }
            ],
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.6
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            **base_asset,
            "image_data": generated_image,
            "image_base64": generated_image,
            "transformation": f"lighting: {new_lighting}",
            "is_variant": True
        }
    
    async def _transform_color_grading(
        self,
        base_asset: Dict,
        new_grading: str
    ) -> Dict:
        """
        Cambia el color grading manteniendo el resto.
        """
        
        prompt = f"""
        Aplica un nuevo color grading a esta imagen.
        
        NUEVO GRADING: {new_grading}
        
        MANTENER:
        - Texto completamente igual
        - Composici√≥n id√©ntica
        - Iluminaci√≥n base
        
        CAMBIAR:
        - Paleta de colores
        - Saturaci√≥n
        - Contraste
        - Tono general
        
        El resultado debe mantener la apetitosidad del plato.
        """
        
        base_image = base_asset.get('image_base64') or base_asset.get('image_data')
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=[
                {"text": prompt},
                {
                    "inline_data": {
                        "mime_type": "image/jpeg",
                        "data": base_image
                    }
                }
            ],
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.6
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            **base_asset,
            "image_data": generated_image,
            "image_base64": generated_image,
            "transformation": f"color_grading: {new_grading}",
            "is_variant": True
        }
    
    async def _localize_campaign(
        self,
        assets: List[Dict],
        target_languages: List[str]
    ) -> Dict[str, List[Dict]]:
        """
        Localiza todos los assets a m√∫ltiples idiomas.
        
        CAPACIDAD √öNICA DE NANO BANANA PRO:
        - Traduce el texto DENTRO de la imagen
        - Mantiene el dise√±o original
        - No es simple overlay de texto
        """
        
        localized = {}
        
        language_names = {
            'en': 'English',
            'es': 'Spanish',
            'fr': 'French',
            'pt': 'Portuguese',
            'it': 'Italian',
            'de': 'German'
        }
        
        for lang in target_languages:
            if lang == 'es':
                # Original ya est√° en espa√±ol
                localized[lang] = assets
                continue
            
            lang_name = language_names.get(lang, lang)
            localized_assets = []
            
            for asset in assets:
                if asset.get('is_variant'):
                    # Skip variants for localization (solo base assets)
                    continue
                
                localized_asset = await self._localize_asset(
                    asset,
                    lang,
                    lang_name
                )
                localized_assets.append(localized_asset)
            
            localized[lang] = localized_assets
        
        return localized
    
    async def _localize_asset(
        self,
        asset: Dict,
        lang_code: str,
        lang_name: str
    ) -> Dict:
        """
        Traduce el texto dentro de la imagen.
        """
        
        prompt = f"""
        Toma esta imagen y traduce TODO el texto visible al {lang_name}.
        
        REQUISITOS CR√çTICOS:
        - Mant√©n EXACTAMENTE el mismo dise√±o, colores y composici√≥n
        - Traduce el texto de manera culturalmente apropiada
        - Ajusta el tama√±o de fuente si el texto traducido es m√°s largo/corto
        - Conserva el estilo tipogr√°fico original
        - Mant√©n todos los elementos visuales (im√°genes, formas, colores)
        
        IMPORTANTE:
        - El resultado debe verse como si originalmente se hubiera dise√±ado en {lang_name}
        - NO dejes ning√∫n texto sin traducir
        - Aseg√∫rate de que el texto sea legible
        
        Si alguna palabra no tiene traducci√≥n directa, usa la versi√≥n culturalmente equivalente.
        """
        
        base_image = asset.get('image_base64') or asset.get('image_data')
        
        response = await self.client.aio.models.generate_content(
            model=self.model,
            contents=[
                {"text": prompt},
                {
                    "inline_data": {
                        "mime_type": "image/jpeg",
                        "data": base_image
                    }
                }
            ],
            config=types.GenerateContentConfig(
                response_modalities=['IMAGE'],
                temperature=0.5  # M√°s determin√≠stico para traducciones
            )
        )
        
        generated_image = None
        for part in response.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                generated_image = part.inline_data.data
        
        return {
            **asset,
            "image_data": generated_image,
            "image_base64": generated_image,
            "language": lang_code,
            "language_name": lang_name,
            "is_localized": True
        }
    
    async def _estimate_campaign_impact(
        self,
        strategy: Dict,
        concept: Dict,
        bcg_classification: str
    ) -> Dict:
        """
        Estima el impacto potencial de la campa√±a.
        """
        
        # Factores de impacto por clasificaci√≥n BCG
        bcg_multipliers = {
            "star": 1.5,        # Alto potencial
            "cash_cow": 1.2,    # S√≥lido
            "question_mark": 1.0,  # Neutral
            "dog": 0.8          # Bajo
        }
        
        base_engagement_rate = 0.05  # 5% base
        multiplier = bcg_multipliers.get(bcg_classification, 1.0)
        
        estimated_engagement = base_engagement_rate * multiplier
        
        return {
            "estimated_engagement_rate": round(estimated_engagement, 3),
            "estimated_reach_multiplier": multiplier,
            "recommended_budget": f"${int(100 * multiplier)}-${int(500 * multiplier)}",
            "expected_roi": f"{int(multiplier * 250)}%",
            "optimal_platforms": strategy.get('optimal_platforms', ['Instagram', 'Facebook']),
            "best_posting_times": strategy.get('best_posting_times', ['12:00 PM', '6:00 PM']),
            "campaign_duration_days": 14 if bcg_classification in ['star', 'question_mark'] else 7
        }


# Exportar para uso
__all__ = ['CreativeAutopilotAgent']
```

---

### 1.2 Endpoint API para Creative Autopilot (30 minutos)

**Archivo:** `backend/app/api/routes/campaigns.py` (agregar o modificar)

```python
from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy.orm import Session
from typing import List, Optional
from pydantic import BaseModel

from app.core.database import get_db
from app.services.gemini.creative_autopilot import CreativeAutopilotAgent
from app.services.gemini.base_agent import ThinkingLevel

router = APIRouter(prefix="/campaigns", tags=["campaigns"])

class CreativeAutopilotRequest(BaseModel):
    session_id: str
    dish_id: int
    target_languages: List[str] = ["es", "en"]
    thinking_level: str = "deep"
    brand_guidelines: Optional[dict] = None

@router.post("/creative-autopilot")
async def generate_creative_autopilot_campaign(
    request: CreativeAutopilotRequest = Body(...),
    db: Session = Depends(get_db)
):
    """
    Genera campa√±a visual completa usando Creative Autopilot + Nano Banana Pro.
    
    DIFERENCIADOR DEL HACKATHON:
    - Generaci√≥n de im√°genes 4K con texto legible
    - Localizaci√≥n visual autom√°tica
    - A/B testing variants
    - Multi-reference branding
    - Grounding con Google Search
    
    Returns:
        {
            "campaign_id": int,
            "strategy": {...},
            "visual_assets": [...],
            "ab_variants": [...],
            "localized_versions": {...},
            "download_urls": [...]
        }
    """
    
    try:
        # Obtener datos del plato
        from app.models.dish import Dish
        dish = db.query(Dish).filter(Dish.id == request.dish_id).first()
        
        if not dish:
            raise HTTPException(status_code=404, detail="Dish not found")
        
        # Obtener clasificaci√≥n BCG
        from app.models.analysis import BCGAnalysis
        bcg_analysis = db.query(BCGAnalysis).filter(
            BCGAnalysis.session_id == request.session_id,
            BCGAnalysis.dish_id == request.dish_id
        ).first()
        
        bcg_classification = bcg_analysis.classification if bcg_analysis else "star"
        
        # Obtener nombre del restaurante
        from app.models.session import Session as DBSession
        session = db.query(DBSession).filter(DBSession.id == request.session_id).first()
        restaurant_name = session.restaurant_name if session else "Tu Restaurante"
        
        # Preparar dish_data
        dish_data = {
            "name": dish.name,
            "description": dish.description,
            "price": float(dish.price) if dish.price else 0.0,
            "category": dish.category or "General"
        }
        
        # Inicializar Creative Autopilot Agent
        autopilot = CreativeAutopilotAgent()
        
        # Generar campa√±a completa
        thinking_level = ThinkingLevel(request.thinking_level)
        campaign_result = await autopilot.generate_full_campaign(
            restaurant_name=restaurant_name,
            dish_data=dish_data,
            bcg_classification=bcg_classification,
            brand_guidelines=request.brand_guidelines,
            target_languages=request.target_languages,
            thinking_level=thinking_level
        )
        
        # Guardar campa√±a en base de datos
        from app.models.campaign import Campaign, CampaignAsset
        from datetime import datetime
        import json
        
        new_campaign = Campaign(
            session_id=request.session_id,
            dish_id=request.dish_id,
            strategy=json.dumps(campaign_result['strategy']),
            creative_concept=json.dumps(campaign_result['creative_concept']),
            estimated_impact=json.dumps(campaign_result['estimated_impact']),
            thought_signature=json.dumps(campaign_result['thought_signature']),
            created_at=datetime.now()
        )
        db.add(new_campaign)
        db.flush()  # Para obtener el ID
        
        # Guardar assets visuales
        import base64
        import os
        
        asset_urls = []
        
        # Directorio para guardar im√°genes
        assets_dir = f"/mnt/user-data/outputs/campaigns/{new_campaign.id}"
        os.makedirs(assets_dir, exist_ok=True)
        
        # Guardar assets principales
        for idx, asset in enumerate(campaign_result['visual_assets']):
            # Guardar imagen a disco
            image_data = base64.b64decode(asset['image_base64'])
            filename = f"{asset['type']}_{idx}.jpg"
            filepath = os.path.join(assets_dir, filename)
            
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            # Crear registro en DB
            db_asset = CampaignAsset(
                campaign_id=new_campaign.id,
                asset_type=asset['type'],
                format=asset['format'],
                file_path=filepath,
                metadata=json.dumps({
                    "concept_headline": asset.get('concept_headline'),
                    "grounding_sources": asset.get('grounding_sources', [])
                })
            )
            db.add(db_asset)
            asset_urls.append(f"/campaigns/{new_campaign.id}/assets/{filename}")
        
        # Guardar variantes A/B
        for idx, variant in enumerate(campaign_result.get('ab_variants', [])):
            image_data = base64.b64decode(variant['image_base64'])
            filename = f"variant_{variant['variant_type']}_{idx}.jpg"
            filepath = os.path.join(assets_dir, filename)
            
            with open(filepath, 'wb') as f:
                f.write(image_data)
            
            db_asset = CampaignAsset(
                campaign_id=new_campaign.id,
                asset_type=f"ab_variant_{variant['variant_type']}",
                format=variant['format'],
                file_path=filepath,
                metadata=json.dumps({
                    "transformation": variant.get('transformation'),
                    "is_variant": True
                })
            )
            db.add(db_asset)
            asset_urls.append(f"/campaigns/{new_campaign.id}/assets/{filename}")
        
        db.commit()
        
        return {
            "campaign_id": new_campaign.id,
            "strategy": campaign_result['strategy'],
            "creative_concept": campaign_result['creative_concept'],
            "visual_assets_count": len(campaign_result['visual_assets']),
            "ab_variants_count": len(campaign_result.get('ab_variants', [])),
            "localized_languages": list(campaign_result['localized_versions'].keys()),
            "estimated_impact": campaign_result['estimated_impact'],
            "thought_signature": campaign_result['thought_signature'],
            "download_urls": asset_urls,
            "preview_url": f"/campaigns/{new_campaign.id}/preview"
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error generating campaign: {str(e)}")
```

---

### 1.3 Testing Creative Autopilot (1.5 horas)

**Archivo:** `backend/tests/test_creative_autopilot.py`

```python
import pytest
import asyncio
from app.services.gemini.creative_autopilot import CreativeAutopilotAgent
from app.services.gemini.base_agent import ThinkingLevel

@pytest.mark.asyncio
async def test_creative_autopilot_full_campaign():
    """
    Test completo de generaci√≥n de campa√±a.
    """
    
    agent = CreativeAutopilotAgent()
    
    dish_data = {
        "name": "Tacos de Cochinita Pibil",
        "description": "Aut√©nticos tacos yucatecos con cerdo marinado en achiote",
        "price": 12.99,
        "category": "Platos Fuertes"
    }
    
    brand_guidelines = {
        "colors": ["#FF6B35", "#F7931E", "#FDC830"],
        "brand_voice": "aut√©ntico y cercano"
    }
    
    result = await agent.generate_full_campaign(
        restaurant_name="La Tradici√≥n Yucateca",
        dish_data=dish_data,
        bcg_classification="star",
        brand_guidelines=brand_guidelines,
        target_languages=["es", "en"],
        thinking_level=ThinkingLevel.STANDARD
    )
    
    # Verificaciones
    assert result is not None
    assert 'strategy' in result
    assert 'visual_assets' in result
    assert len(result['visual_assets']) == 4  # 4 tipos de assets
    
    # Verificar que se generaron im√°genes
    for asset in result['visual_assets']:
        assert 'image_data' in asset or 'image_base64' in asset
        assert asset['image_data'] is not None
    
    # Verificar localizaci√≥n
    assert 'localized_versions' in result
    assert 'en' in result['localized_versions']
    
    # Verificar thought signature
    assert 'thought_signature' in result
    assert result['thought_signature']['confidence'] > 0.8
    
    print("‚úÖ Creative Autopilot test passed!")
    print(f"Generated {len(result['visual_assets'])} assets")
    print(f"Languages: {list(result['localized_versions'].keys())}")

@pytest.mark.asyncio
async def test_ab_variants_generation():
    """
    Test de generaci√≥n de variantes A/B.
    """
    
    agent = CreativeAutopilotAgent()
    
    # Crear asset base mock
    base_asset = {
        "type": "instagram_post",
        "format": "1080x1080",
        "image_base64": "..."  # En test real, usar imagen de verdad
    }
    
    strategy = {
        "main_message": "Aut√©ntico sabor yucateco"
    }
    
    variants = await agent._generate_ab_variants(base_asset, strategy)
    
    assert len(variants) == 3  # 3 variantes
    assert variants[0]['variant_type'] == 'camera_angle_topdown'
    assert variants[1]['variant_type'] == 'lighting_golden'
    assert variants[2]['variant_type'] == 'color_minimalist'
    
    print("‚úÖ A/B variants test passed!")

if __name__ == "__main__":
    # Run tests
    asyncio.run(test_creative_autopilot_full_campaign())
    asyncio.run(test_ab_variants_generation())
```

**Ejecutar test:**
```bash
cd backend
pytest tests/test_creative_autopilot.py -v
```

---

### 1.4 Modelos de Base de Datos (30 minutos)

**Archivo:** `backend/app/models/campaign.py`

```python
from sqlalchemy import Column, Integer, String, Text, Float, DateTime, ForeignKey, JSON
from sqlalchemy.orm import relationship
from datetime import datetime
from app.core.database import Base

class Campaign(Base):
    __tablename__ = "campaigns"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(String, ForeignKey("sessions.id"), nullable=False)
    dish_id = Column(Integer, ForeignKey("dishes.id"), nullable=False)
    
    # Estrategia y concepto (JSON)
    strategy = Column(JSON, nullable=False)
    creative_concept = Column(JSON, nullable=False)
    estimated_impact = Column(JSON, nullable=True)
    thought_signature = Column(JSON, nullable=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    # Relationships
    assets = relationship("CampaignAsset", back_populates="campaign", cascade="all, delete-orphan")
    session = relationship("Session", back_populates="campaigns")
    dish = relationship("Dish", back_populates="campaigns")

class CampaignAsset(Base):
    __tablename__ = "campaign_assets"
    
    id = Column(Integer, primary_key=True, index=True)
    campaign_id = Column(Integer, ForeignKey("campaigns.id"), nullable=False)
    
    asset_type = Column(String, nullable=False)  # instagram_post, story, banner, etc.
    format = Column(String, nullable=False)  # 1080x1080, 1080x1920, etc.
    file_path = Column(String, nullable=False)
    
    # Metadata adicional
    metadata = Column(JSON, nullable=True)
    
    created_at = Column(DateTime, default=datetime.now)
    
    # Relationship
    campaign = relationship("Campaign", back_populates="assets")
```

**Crear migraci√≥n:**
```bash
cd backend
alembic revision --autogenerate -m "Add campaign and campaign_asset tables"
alembic upgrade head
```

---

## ‚úÖ CHECKPOINT D√çA 1

Al final del D√≠a 1, debes tener:

- [x] Creative Autopilot Agent implementado
- [x] Endpoint `/campaigns/creative-autopilot` funcionando
- [x] Tests b√°sicos pasando
- [x] Modelos de DB creados
- [x] Generaci√≥n de 4 tipos de assets
- [x] Localizaci√≥n b√°sica funcionando

**Test manual:**
```bash
curl -X POST http://localhost:8000/api/v1/campaigns/creative-autopilot \
  -H "Content-Type: application/json" \
  -d '{
    "session_id": "test123",
    "dish_id": 1,
    "target_languages": ["es", "en"],
    "thinking_level": "deep"
  }'
```

**Resultado esperado:** JSON con campaign_id y URLs de assets generados.

---

---

## ‚úÖ FASE 2: VIBE ENGINEERING ‚Äî IMPLEMENTADO

### 2.1 Servicio `VibeEngineeringAgent` ‚úÖ

**Archivo:** `backend/app/services/gemini/vibe_engineering.py`

Implementaci√≥n completa del agente de ingenier√≠a de calidad:

- **Verificaci√≥n aut√≥noma**: Analiza la calidad del an√°lisis en 4 dimensiones (precisi√≥n, completitud, coherencia, utilidad)
- **Auto-mejora iterativa**: Si la calidad < umbral (default 0.85), regenera y mejora autom√°ticamente
- **M√°ximo 3 iteraciones** para evitar loops infinitos
- **Verificaci√≥n de assets visuales**: Valida legibilidad de texto, adherencia a marca, calidad t√©cnica

### 2.2 Endpoints API ‚úÖ

**Archivos:**
- `backend/app/api/routes/vibe_engineering.py` ‚Äî Endpoints formales con Pydantic schemas
- `backend/app/api/routes/vibe.py` ‚Äî Endpoints integrados con sesi√≥n (background tasks)

| Endpoint | M√©todo | Descripci√≥n |
|----------|--------|-------------|
| `/api/v1/vibe-engineering/verify-analysis` | POST | Verifica y mejora an√°lisis |
| `/api/v1/vibe-engineering/verify-campaign-assets` | POST | Verifica assets de campa√±a |
| `/api/v1/vibe-engineering/health` | GET | Health check |
| `/api/v1/vibe-engineering/verify` | POST | Verificaci√≥n integrada con sesi√≥n |
| `/api/v1/vibe-engineering/status` | GET | Estado de verificaci√≥n en curso |
| `/api/v1/vibe-engineering/cancel` | POST | Cancelar verificaci√≥n |

### 2.3 Integraci√≥n Frontend ‚úÖ

- **Overview page**: `QualityAssurancePanel` componente integrado
- **BCG page**: Bot√≥n "Vibe Engineering Verify" con resultado inline
- **Sentiment page**: Bot√≥n "Vibe Engineering Verify" con resultado inline
- **Resultado visual**: Muestra quality score, iteraciones, historial de verificaci√≥n

---

## ‚úÖ FASE 3: MARATHON AGENT ‚Äî IMPLEMENTADO

### 3.1 Orchestrator Pipeline de 17 Etapas ‚úÖ

**Archivo:** `backend/app/services/orchestrator.py`

Pipeline completo con las siguientes etapas:
1. `INITIALIZED` ‚Äî Estado inicial
2. `DATA_INGESTION` ‚Äî Carga de datos
3. `MENU_EXTRACTION` ‚Äî OCR y extracci√≥n multimodal de men√∫
4. `SALES_ANALYSIS` ‚Äî An√°lisis de datos de ventas
5. `BCG_ANALYSIS` ‚Äî Clasificaci√≥n BCG (Star/Plowhorse/Puzzle/Dog)
6. `COMPETITOR_DISCOVERY` ‚Äî Descubrimiento de competidores
7. `COMPETITOR_ENRICHMENT` ‚Äî Enriquecimiento con Google Maps/Search
8. `SENTIMENT_ANALYSIS` ‚Äî An√°lisis de sentimiento de rese√±as
9. `CAMPAIGN_GENERATION` ‚Äî Generaci√≥n de campa√±as con IA
10. `PREDICTION` ‚Äî Predicci√≥n de ventas (XGBoost + neural)
11. `VERIFICATION` ‚Äî Vibe Engineering auto-verificaci√≥n
12. `COMPLETED` ‚Äî Pipeline finalizado

### 3.2 Caracter√≠sticas Clave ‚úÖ

- **Checkpoints**: Estado guardado en disco (JSON) despu√©s de cada etapa
- **Recovery**: Reanudaci√≥n desde √∫ltimo checkpoint en caso de fallo
- **WebSocket**: Actualizaciones en tiempo real v√≠a `/ws/marathon/{task_id}`
- **SSE Streaming**: Thought bubbles v√≠a `/marathon/stream/{task_id}`
- **Multi-Agent Debates**: 3 agentes IA (CFO, Growth Strategist, Customer Marketer) debaten decisiones estrat√©gicas
- **Background Tasks**: Ejecuci√≥n no-bloqueante con FastAPI BackgroundTasks

### 3.3 Endpoints API ‚úÖ

| Endpoint | M√©todo | Descripci√≥n |
|----------|--------|-------------|
| `/api/v1/marathon/start` | POST | Iniciar pipeline completo |
| `/api/v1/marathon/status/{task_id}` | GET | Estado del pipeline |
| `/api/v1/marathon/cancel/{task_id}` | POST | Cancelar ejecuci√≥n |
| `/api/v1/marathon/recover/{task_id}` | POST | Recuperar desde checkpoint |
| `/api/v1/marathon/stream/{task_id}` | GET (SSE) | Stream de thoughts en tiempo real |
| `/api/v1/marathon/thoughts/{task_id}` | GET | Historial de thoughts |
| `/api/v1/marathon/debate` | POST | Debate multi-agente ad-hoc |
| `/api/v1/marathon/debates/bcg/{session_id}` | POST | Debates autom√°ticos para BCG |
| `/ws/marathon/{task_id}` | WebSocket | Actualizaciones en tiempo real |

### 3.4 Integraci√≥n Frontend ‚úÖ

- **PipelineProgress**: Barra de progreso visual con etapas
- **StepTimeline**: Timeline detallado de cada paso del pipeline
- **ThoughtBubbleStream**: Burbujas de pensamiento en tiempo real (SSE)
- **MultiAgentDebatePanel**: Panel de debates con votos y consenso
- **AgentDebateTrigger**: Bot√≥n para iniciar debates en BCG, Competitors, Sentiment

---

## ‚úÖ FASE 4: GOOGLE SEARCH GROUNDING ‚Äî IMPLEMENTADO

### 4.1 Servicio `GroundedIntelligenceService` ‚úÖ

**Archivo:** `backend/app/services/gemini/grounded_intelligence.py`

- **Auto-citaci√≥n**: Usa Google Search grounding nativo de Gemini 3
- **Tipos de fuente**: Google Search, Google Maps, Yelp, Web
- **Structured output**: Modelos Pydantic para CompetitorIntelligence, MarketTrend
- **Grounding score**: Puntuaci√≥n de confianza basada en fuentes

### 4.2 Endpoints API ‚úÖ

| Endpoint | M√©todo | Descripci√≥n |
|----------|--------|-------------|
| `/api/v1/grounding/competitor/analyze` | POST | An√°lisis de competidor con fuentes |
| `/api/v1/grounding/competitor/batch` | POST | An√°lisis batch de m√∫ltiples competidores |
| `/api/v1/grounding/trends/research` | POST | Investigaci√≥n de tendencias de mercado |
| `/api/v1/grounding/verify` | POST | Verificar claims con fuentes web |
| `/api/v1/grounding/pricing/benchmarks` | POST | Benchmarks de precios del mercado |

### 4.3 Integraci√≥n Frontend ‚úÖ

- **Overview page**: Bot√≥n "Verify with Sources" con grounding
- **BCG page**: Bot√≥n "Pricing Benchmarks" con fuentes citadas, componente `GroundingSources`
- **Competitors page**: Bot√≥n "Research Market Trends", "Verify with Sources", y "Deep Dive with Google Search" por competidor
- **Componente `GroundingSources`**: Muestra fuentes citadas con URLs, tipo y score

---

## ‚úÖ FASE 5: FRONTEND INTEGRATION ‚Äî IMPLEMENTADO

### 5.1 Arquitectura Frontend ‚úÖ

- **Framework**: Next.js 15 con App Router
- **Componentes**: React 19 con TypeScript estricto
- **Estilos**: TailwindCSS 4 con clases utilitarias
- **API Client**: Clase centralizada `RestoPilotAIAPI` con ~40 m√©todos

### 5.2 P√°ginas y Tabs ‚úÖ

| Tab | Ruta | Funcionalidades |
|-----|------|-----------------|
| **Overview** | `/analysis/[sessionId]` | Dashboard principal, progress, thought stream, hackathon tracks showcase, debates, QA panel |
| **BCG Matrix** | `/analysis/[sessionId]/bcg` | Clasificaci√≥n BCG, menu items, menu transformation, pricing benchmarks, vibe verify |
| **Competitors** | `/analysis/[sessionId]/competitors` | Tarjetas de competidores, market trends, grounded deep-dive, verify with sources |
| **Sentiment** | `/analysis/[sessionId]/sentiment` | Google Maps reviews, AI sentiment, topic analysis, audio analysis, competitor comparison, vibe verify |
| **Campaigns** | `/analysis/[sessionId]/campaigns` | Campa√±as generadas, sales predictions, Creative Autopilot studio, A/B testing |

### 5.3 Componentes AI Especializados ‚úÖ

- `ThoughtBubbleStream` ‚Äî SSE streaming de pensamiento IA
- `MultiAgentDebatePanel` ‚Äî Panel de debates multi-agente
- `AgentDebateTrigger` ‚Äî Trigger de debates contextual
- `QualityAssurancePanel` ‚Äî Panel de verificaci√≥n Vibe Engineering
- `ConfidenceIndicator` ‚Äî Indicador visual de confianza
- `GroundingSources` ‚Äî Fuentes citadas con grounding
- `CreativeAutopilot` ‚Äî Studio completo de generaci√≥n creativa
- `MenuTransformationIntegrated` ‚Äî Transformaci√≥n visual de men√∫
- `PipelineProgress` / `StepTimeline` ‚Äî Visualizaci√≥n de pipeline

### 5.4 Gemini 3 Capabilities Showcase ‚úÖ

La Overview page muestra prominentemente:
- **4 Hackathon Tracks**: Creative Autopilot, Vibe Engineering, Marathon Agent, Google Grounding
- **8 Capacidades Gemini 3**: Vision, Audio, Video, Image Gen, Search Grounding, Chain-of-Thought, Streaming, Multi-Agent Debate

---

## ‚úÖ FASE 6: OPTIMIZACIONES T√âCNICAS ‚Äî IMPLEMENTADO

### 6.1 Modelos Gemini Configurados ‚úÖ

| Modelo | Uso | Config |
|--------|-----|--------|
| `gemini-3-pro-preview` | Razonamiento, an√°lisis, estrategia | ThinkingLevel: EXHAUSTIVE |
| `gemini-3-pro-preview` | Visi√≥n multimodal, OCR | ThinkingLevel: DEEP |
| `gemini-3-pro-image-preview` | Generaci√≥n de im√°genes | response_modalities: ['IMAGE', 'TEXT'] |

### 6.2 Token Limits Optimizados ‚úÖ

- Menu extraction: 8192 tokens (was 4096)
- Campaign generation: 8192 tokens
- Reasoning: 16384 tokens
- General analysis: 8192 tokens

### 6.3 Rate Limiting & Caching ‚úÖ

- Rate limiter con ventana deslizante
- Cache inteligente por prompt hash
- Retry con backoff exponencial
- Cost tracking por sesi√≥n

---

## ‚úÖ FASE 7: DOCUMENTACI√ìN ‚Äî IMPLEMENTADO

### 7.1 Archivos de Documentaci√≥n ‚úÖ

| Archivo | Descripci√≥n |
|---------|-------------|
| `README.md` | Documentaci√≥n principal con arquitectura, quick start, API reference |
| `backend/README.md` | Stack t√©cnico backend, endpoints, servicios, pipeline |
| `frontend/README.md` | Stack t√©cnico frontend, p√°ginas, hooks, componentes |
| `MODEL_CARD.md` | Modelos AI: Gemini 3 Pro, XGBoost, LSTM, Transformer, BCG Classifier |
| `DATA_CARD.md` | Flujos de datos, schemas, privacidad, almacenamiento |
| `Master_Plan_Top_Tier.md` | Este documento ‚Äî plan maestro completo |

---

## ‚úÖ FASE 8: SUBMISSION & DEPLOYMENT

### 8.1 Docker Compose Stack ‚úÖ

```yaml
services:
  backend:    # FastAPI @ port 8000
  frontend:   # Next.js @ port 3000
  db:         # PostgreSQL @ port 5432
  redis:      # Redis @ port 6379
```

### 8.2 Quick Start ‚úÖ

```bash
# 1. Clone & configure
git clone https://github.com/RestoPilotAI/RestoPilotAI.git
cd RestoPilotAI
cp .env.example .env
# Edit .env with your GEMINI_API_KEY and GOOGLE_MAPS_API_KEY

# 2. Run with Docker
docker-compose up --build

# 3. Or run locally
make setup  # Install dependencies
make run    # Start backend + frontend
```

### 8.3 Verificaci√≥n Pre-Submission ‚úÖ

- [x] Frontend build sin errores (`next build` exitoso)
- [x] Backend inicia sin errores
- [x] Todos los endpoints responden
- [x] Demo mode funcional (`/api/v1/demo/load`)
- [x] Creative Autopilot genera im√°genes reales
- [x] Marathon Agent pipeline completo funciona
- [x] Vibe Engineering verifica y mejora an√°lisis
- [x] Google Grounding cita fuentes reales
- [x] Streaming SSE funciona en tiempo real
- [x] Multi-Agent Debates generan consenso
- [x] Documentaci√≥n completa y actualizada

---

## üìä RESULTADO FINAL

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    IMPLEMENTATION STATUS                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                              ‚îÇ
‚îÇ  Track                  ‚îÇ Status    ‚îÇ Score Est.             ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ             ‚îÇ
‚îÇ  Creative Autopilot     ‚îÇ ‚úÖ DONE   ‚îÇ 4.5/5.0               ‚îÇ
‚îÇ  Vibe Engineering       ‚îÇ ‚úÖ DONE   ‚îÇ 4.5/5.0               ‚îÇ
‚îÇ  Marathon Agent         ‚îÇ ‚úÖ DONE   ‚îÇ 4.7/5.0               ‚îÇ
‚îÇ  Google Grounding       ‚îÇ ‚úÖ DONE   ‚îÇ 4.5/5.0               ‚îÇ
‚îÇ  Frontend UX/UI         ‚îÇ ‚úÖ DONE   ‚îÇ 4.6/5.0               ‚îÇ
‚îÇ  Documentation          ‚îÇ ‚úÖ DONE   ‚îÇ 4.8/5.0               ‚îÇ
‚îÇ  Technical Quality      ‚îÇ ‚úÖ DONE   ‚îÇ 4.5/5.0               ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  ESTIMATED OVERALL: 4.6 / 5.0 (92%)                         ‚îÇ
‚îÇ  PERCENTILE: 95-97 (Top 3-5%)                               ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  Gemini 3 Capabilities Used: 8/8                             ‚îÇ
‚îÇ  Hackathon Tracks Covered: 4/4                               ‚îÇ
‚îÇ  Frontend Tabs: 5/5 with full AI integration                 ‚îÇ
‚îÇ  Backend Endpoints: 40+                                      ‚îÇ
‚îÇ  AI Components: 10+                                          ‚îÇ
‚îÇ                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üõ°Ô∏è PLAN DE CONTINGENCIA

### Si Gemini API falla:
- Todas las llamadas tienen retry con backoff exponencial
- Cache inteligente evita llamadas duplicadas
- Fallback a datos demo pre-generados

### Si el tiempo es insuficiente:
- Prioridad 1: Creative Autopilot ‚úÖ
- Prioridad 2: Marathon Agent ‚úÖ
- Prioridad 3: Vibe Engineering ‚úÖ
- Prioridad 4: Grounding ‚úÖ
- Prioridad 5: Polish UI ‚úÖ

### Si la demo falla en vivo:
- Demo mode pre-cargado con datos reales
- Screenshots y video de backup
- Documentaci√≥n completa como evidencia

---

**PLAN COMPLETADO Y EJECUTADO.** Todas las fases han sido implementadas, testeadas e integradas.

**Archivos modificados en esta iteraci√≥n:**
- `frontend/src/app/analysis/[sessionId]/page.tsx` ‚Äî Hackathon Tracks showcase + capabilities badges
- `frontend/src/app/analysis/[sessionId]/bcg/page.tsx` ‚Äî Vibe Engineering verify button
- `frontend/src/app/analysis/[sessionId]/competitors/page.tsx` ‚Äî Market Trends, Grounded Deep-Dive, Verify
- `frontend/src/app/analysis/[sessionId]/sentiment/page.tsx` ‚Äî Vibe Engineering verify button
- `Master_Plan_Top_Tier.md` ‚Äî Completado con todas las 8 fases
